# Лабораторная работа №6: Система сериализации данных в пользовательском формате

## Цель работы
Разработка собственной системы сериализации данных с реализацией парсера пользовательского формата. Освоение принципов работы с форматами данных, парсинга и сериализации/десериализации структур.

## Техническое задание

### 1. Разработка пользовательского формата данных
**Задача:** Заменить бинарное хранение данных из лабораторной работы №4 на текстовый формат собственной разработки ИЛИ JSON.

**Требования к кастомному формату:**
- **Текстовый формат** - данные должны храниться в читаемом виде
- **Структурированность** - возможность хранения сложных структур данных
- **Простота парсинга** - минимальный набор синтаксических конструкций
- **Поддержка типов** - как минимум: строки, числа, булевы значения, массивы, объекты

### 2. Реализация парсера формата
**Требования к парсеру:**
- Написание парсера "с нуля" без использования готовых библиотек JSON/XML
- Поддержка чтения (десериализации) из пользовательского формата (или JSON)
- Поддержка записи (сериализации) в пользовательский формат (или JSON)

### 3. Формат данных (ПРИМЕР варианта синтаксиса)
```plaintext
// Пример пользовательского формата (например, SimpleDataFormat - SDF)
user = {
    username = "baragodlike"
    password_hash = for_my_fav_fst_course
    is_active = true
    permissions = [ "read" "write" "delete" ]
}

// Пример пользовательского формата (например, PaPricoluFormat - PPF)
data = list:
    object:
        id = 1
        name = "Пример записи"
        value = 42.5
        tags = list: 
          "важное"
          "тест"
    object:
        id = 2
        name = "Вторая запись"
        value = -15
        tags = list:
```

### 4. Требования к синтаксису формата
**Минимальный набор конструкций:**
1. **Комментарии** - однострочные (`//`) и/или многострочные (`/* */`)
2. **Пары ключ-значение** - `ключ = значение` или `ключ: значение` или свой вариант
3. **Типы данных:**
   - Строки: `"текст в кавычках"`
   - Числа: `42`, `-3.14`, `0xFF`
   - Булевы значения: `true`, `false`
   - null: `null`
   - Массивы: `[ значение1, значение2, ... ]` или свой вариант
   - Объекты: `{ ключ1 = значение1, ключ2 = значение2 }` или свой вариант
4. **Разделители** - запятые (опциональные), пробелы, переносы строк (опциональные)

## Требования к реализации

### Архитектура парсера:
ПРИМЕР
```c
// Пример структуры для узла данных
typedef enum {
    NODE_OBJECT,
    NODE_ARRAY,
    NODE_STRING,
    NODE_NUMBER,
    NODE_BOOLEAN,
    NODE_NULL
} NodeType;

typedef struct DataNode {
    NodeType type;
    char* key; // Для объектов
    union {
        char* string_value;
        double number_value;
        int boolean_value;
        struct {
            struct DataNode** items;
            int count;
        } array; // Для массивов и объектов
    } value;
    struct DataNode* next; // Для цепочек в объектах/массивах
} DataNode;
```

### Основные функции парсера:
названия и параметры могут отличаться, но функционал обяазтелен
```c
DataNode* parse_file(const char* filename);
DataNode* parse_string(const char* input);
char* serialize_node(const DataNode* node);
int save_file(const char* filename, const DataNode* root);
```

### Модульная архитектура:
1. **Парсер (parser.c/h)** - основной модуль разбора формата
2. **Сериализатор (serializer.c/h)** - модуль преобразования структур в текст
3. **Валидатор (validator.c/h)** - проверка корректности структуры данных
4. **Адаптер данных (data_adapter.c/h)** - преобразование между бизнес-объектами и форматом

## Критерии оценки

### Код программы (20 баллов):
- **3 балла** - корректно работающий парсер для строк, чисел и булевых значений
- **5 баллов** - корректно работающий парсер для массивов
- **7 баллов** - корректно работающий парсер для объектов
- **2 балла** - возможность писать комментарии
- **3 балла** - корректное преобразование *бизнес-объектов* (структуры из прошлых лабораторных) к формату
