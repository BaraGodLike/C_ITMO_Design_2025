# Лабораторная работа №5: Сравнение производительности однопоточных и многопоточных алгоритмов обработки изображений

## Цель работы
Освоить принципы распараллеливания вычислительно сложных операций, методы синхронизации потоков и анализ производительности на примере обработки изображений.

## Техническое задание

### 1. Общие требования
Разработать программу для обработки изображений в формате PPM (бинарный формат P6) с поддержкой трех фильтров:
- Чёрно-белое преобразование (grayscale)
- Размытие по Гауссу (Gaussian blur)
- Медианный фильтр (median filter)

Для каждого фильтра реализовать **две версии**:
- **Однопоточная** (single-threaded)
- **Многопоточная** (multi-threaded) с использованием библиотеки `pthread`

### 2. Формат изображений
- Входные и выходные изображения в формате **PPM P6** (бинарный)
- Размер тестового изображения: **512×512 пикселей**
- Цветовая глубина: 24 бита (8 бит на канал)

### 3. Реализуемые фильтры

#### 3.1. Чёрно-белое преобразование (Grayscale)
**Алгоритм:**
```
gray = 0.299 * R + 0.587 * G + 0.114 * B
```

#### 3.2. Размытие по Гауссу (Gaussian Blur)
**Параметры:**
- Размер ядра: **5×5**
- Ядро Гаусса (предварительно вычисленное):
```
K = 1/273 * [
    [1,  4,  7,  4, 1],
    [4, 16, 26, 16, 4],
    [7, 26, 41, 26, 7],
    [4, 16, 26, 16, 4],
    [1,  4,  7,  4, 1]
]
```

#### 3.3. Медианный фильтр (Median Filter)
**Параметры:**
- Размер окна: **3×3**
- Алгоритм: для каждого пикселя взять окрестность 3×3, отсортировать значения и взять медиану

### 4. Требования к многопоточной реализации

#### 4.1. Стратегия разделения данных
Реализовать один из методов разделения изображения между потоками, например:
1. **По строкам (Row-based)** - изображение делится на равные горизонтальные полосы
2. **По блокам (Tile-based)** - изображение делится на квадратные блоки

```c
// Пример структуры для передачи данных в поток
typedef struct {
    Pixel** input;
    Pixel** output;
    int start_row;
    int end_row;
    int width;
    FilterType filter_type;
    void* filter_params;
} ThreadData;
```

#### 4.2. Управление потоками
- Использовать фиксированное число потоков: **2, 4, 8**
- Корректное создание и завершение потоков
- Обработка ошибок при создании потоков

#### 4.3. Синхронизация
- Для фильтра размытия: потоки работают независимо
- Для медианного фильтра: потоки работают независимо
- Общая структура изображения должна быть защищена при необходимости

### 5. Система измерения производительности

#### 5.1. Точные замеры времени
Использовать высокоточные таймеры:
```c
#include <time.h>
#include <sys/time.h>

double get_current_time() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec + tv.tv_usec * 1e-6;
}
```

#### 5.2. Протокол тестирования
Для каждого фильтра выполнить:
1. **Холодный запуск** (первое выполнение, кэш пустой)
2. **Горячий запуск** (5 итераций, усреднить результаты)
3. Измерить время для:
   - Однопоточной версии
   - Многопоточной версии (2 потока)
   - Многопоточной версии (4 потока)
   - Многопоточной версии (8 потоков)

### 6. Анализ результатов

#### 6.1. Вычисление метрик
Для каждой конфигурации вычислить:
- **Время выполнения** (секунды)
- **Ускорение (Speedup)** = T₁ / Tₙ
- **Эффективность (Efficiency)** = Speedup / n × 100%

#### 6.2. Формат отчёта
Создать таблицы сравнения:

**Таблица 1: Абсолютное время выполнения (секунды)**
| Фильтр | Single | Threads=2 | Threads=4 | Threads=8 |
|--------|--------|-----------|-----------|-----------|
| Grayscale | | | | |
| Gaussian | | | | |
| Median | | | | |

**Таблица 2: Ускорение (Speedup)**
| Фильтр | Threads=2 | Threads=4 | Threads=8 |
|--------|-----------|-----------|-----------|
| Grayscale | | | |
| Gaussian | | | |
| Median | | | |

### 7. Верификация корректности

#### 7.1. Сравнение результатов
- Результаты однопоточной и многопоточной версий должны быть **бинарно идентичны**
- Реализовать функцию проверки:
```c
bool compare_images(Pixel** img1, Pixel** img2, int height, int width) {
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            if (img1[i][j].r != img2[i][j].r ||
                img1[i][j].g != img2[i][j].g ||
                img1[i][j].b != img2[i][j].b) {
                return false;
            }
        }
    }
    return true;
}
```

#### 7.2. Тестовые изображения
Создать или использовать тестовое изображение 512×512

### 8. Программный интерфейс

#### 8.1. Командная строка
```
./image_processor <input.ppm> <output.ppm> <filter> [threads]
```
Параметры:
- `input.ppm` - входное изображение
- `output.ppm` - результат обработки
- `filter` - `grayscale`, `gaussian`, `median`
- `threads` - количество потоков (1 для single-threaded)

#### 8.2. Режим бенчмарка
```
./image_processor --benchmark <image.ppm>
```
Режим выполняет все фильтры со всеми конфигурациями потоков и выводит сводную таблицу.

### 9. Требования к реализации

#### 9.1. Модульная структура

Пример:
```
src/
├── ppm_io.c/h           # Чтение/запись PPM P6
├── filters.c/h          # Реализации фильтров
├── single_thread.c/h    # Однопоточные версии
├── multi_thread.c/h     # Многопоточные версии
├── timer.c/h            # Измерение времени
├── benchmark.c/h        # Тесты производительности
└── main.c               # Точка входа
```


### 10. Критерии оценки

#### Код программы (8 баллов):
- **2 балла** - программа корректно обрабатывает изображения в однопоточном режиме
- **4 балла** - программа корректно обрабатывает изображения в многопоточном режиме
- **2 балла** - реализованы бенчмарки

#### Защита работы (4 балла):
Студент уверенно объясняет принципы работы с потоками и отвечает на доп. вопросы


